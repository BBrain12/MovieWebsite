# MovieListApp aka Make a Movie List
#### Video Demo:  <URL https://youtu.be/vK1fIQmqM5Q>
#### Description:
For this final CS50 project, I made a Flask-based web application for creating organized lists of movies. The idea came from a personal and specific need in my life. My wife and I like watching what we call “anniversary movies” or movies that were released theatrically 5, 10, 15, etc. years ago. We keep track of the movies we want to watch using a word document, but it requires a lot of manual work on our end to make entries and keep them organized. With the web application I made, we are now able find movies in a database, add them to a list, have movies automatically organized, and still have the freedom to edit entries we made to our list. 

Originally, I thought it’d be efficient to build an app that could scrape data from a website. I wanted the app to go to imdb.com, take user-given search parameters to find the movie on imdb.com, then find the data I want and add it to a saved list for my website to display. But as I dug into it, I found that the kind of data-scraping I wanted to do would not only be a bit more complicated than I thought, but it would also probably cost some money to regularly authenticate my API requests. So, I decided instead to pull from the lesson we had on SQL and use data from a finite database instead. I downloaded the free tsv files from imdb.com, figured out how to convert them to csv files, and then combine two of them to make the imdbdata.db file I use in the IMDBfiles folder. I would’ve liked to use more data, but I was working on my little laptop and combining the most essential csv files made for a db file that was big enough to give my computer issues with exporting. I decided to cut my losses and use what I had. It still works fine, so I’m happy enough with it. 

To manage the style and format of the website, I have a couple css files in the static folder. The styles.css file was made first and it was used when building the website in the early stages to contain all my app-specific overrides and layout rules for things like text formatting and body layout. At some point, I thought it would make my project look better if it had an actual style and not just plain serif text on a white background. I wasn’t sure how this process would evolve, so I made a second css file so I could experiment with the website’s style and also have the freedom to trash it and not affect my website if I didn’t like the direction it was going. I thought it’d be fun if the website had a style that was reminiscent of an 18th century document. I looked online and found some css code that gave me the style I wanted, so I copied it over and tweaked it a bit until I was satisfied with the look. When the style felt done and I made sure the website still worked cohesively, I kept working on features. In hindsight, I probably should’ve put in the effort to make my project more clean by combining the css files, but again I decided to cut my losses and say that it worked well enough for me. 

From the start, one feature I opted not to include is the creation of individual profiles for the website. This was a problem we tackled in Problem Set 9 for the Finance assignment. I went back and forth on this, but I ultimately decided that because this website was just going to be used by my wife and me, my website didn’t need the code for allowing individual user profiles with passwords. If I ever wanted to make my website public, that feature could always be implemented later. 

The backend is operated in the app.py file. This is where the Flask server handles all business logic and database operations. It’s a RESTful API that communicates with the frontend via JSON (more on that in a few paragraphs). This file accomplishes two major functions: movie search and list management. 

For managing the main movie search function in app.py, the file has paths that point to the SQLite database that contains all the movie information I downloaded from imdb.com. For the movie search part, the user can give a film’s title, release year, or both. The search is a lot faster and more precise if the user provides both, but it will still give 10 results with just the title. While the search is as precise as you might expect from giving the title, I allowed the release year to be flexible by one year higher or lower. I included this flexibility because sometimes there was a discrepancy between what I perceived the release year to be and what it actually was. Additionally, because the search results display the year of the film, the user can see how precise the reality of the release year is to reality (i.e. if I was trying to add a 1986 film to my list but the film actually came out in 1987, I won’t add it). 

The list management function of app.py was the most fun to work on. It uses a ‘saved’ table in the database to keep track of lists and movies in those lists. When a movie is added from the search window, it is saved onto the current list and automatically grouped by the first genre that is listed in the metadata. The movie’s title and runtime is displayed after being organized first by release year, then genre. The most important feature I added here is the ability to edit entries without changing the source’s metadata. The website doesn’t do everything that I would want, so the edit feature is a great band-aid for changing things as needed. For example, I can change the film’s genre if I want it to be grouped differently, and if I do, then the film is automatically re-organized in the list. This also allows me to add another feature I’m used to having in the old WordDoc version of this idea: the ability to add a synopsis to a film. I decided to include a character limit to the synopsis, not that I would ever write an excessive synopsis, but mostly so that if I did go public with this project, it was a tad more idiot-proof. It was a little tough tweaking the style because I wanted the synopsis to show up smaller than all the other text, but I got it working.

The .venv folder is a Python virtual environment used for containing all project dependencies. I had to learn online that a folder like this is needed for isolating the project dependencies from my Python system. It contains the Python executable, pip package manager, Flask, and activation scripts for different shells I needed and might need in the future. 

For the frontend, the JavaScript code (written in the index.html and app.js files) runs in the browser and provides the user interface. It communicates with the Flask backend via fetch API. It does a lot of the stuff you’d expect it to like calling a bunch of async functions to do things like use GET and POST to fetch and display information in an organized fashion. One fun feature I added in this part is the formatRuntime function that alters how the runtime of a film is displayed. In the database, a film’s runtime is recorded as the total number of minutes in a film. For me, seeing a film’s minutes is like seeing military time; I have to do math in my head in order to understand it. So, I made a feature that automatically calculates and converts a film’s runtime from minutes (135) to a HH:MM format (2:15). Much easier, I think!
